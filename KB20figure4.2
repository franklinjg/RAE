"""
Necessary Libraries for Analysis Replication:
-----------------------------------------------------
To replicate my analysis, the libraries used in this code must be installed. If you encounter any issues with the installations, execute the following commands in your terminal:

For Python 2.x:
    pip install "library_name"

For Python 3.x:
    pip3 install "library_name"

Seed for Reproducibility:
-----------------------------------------------------
The random seed is set to 4862 to ensure that the results are reproducible. It's important to note that setting a fixed seed is not the most efficient approach for achieving randomness. The fixed seed is used here only to meet a specific requirement. For scenarios involving large numbers, consider utilizing quasi-random number generators, as they provide a more evenly distributed sequence of numbers and actively prevent clustering.

Special thanks to my friend Nishanth for his helpful comments. P.D. My code does not comply with PEP 8 standards. I am aware of this and I am working on it.

This code reproduces figure 4.2
"""




import numpy as np
import matplotlib.pyplot as plt
from scipy.special import comb

# Set the seed for reproducibility
np.random.seed(4862)

# Constants and Psi values range
n = 20
phi = 0.20
X = 5.0
q = 0.5
vmax = 1.0
Psi_values = np.arange(0.01, 0.14, 0.01)

# Function to compute phi*
def phistar(Psi):
    return 2 * Psi * phi

# Function to generate an adjusted matrix G
def generate_adjusted_matrix(n):
    G = np.zeros((n, n))
    possible_values = [0.5, -0.5, 1, 0]
    for i in range(n):
        row_sum = 0
        for j in range(n):
            if i == j:
                continue
            if j == n - 1:
                G[i, j] = 1 - row_sum
            else:
                value = np.random.choice(possible_values)
                if row_sum + value > 1 or (j == n - 2 and row_sum + value + 0.5 > 1):
                    value = 1 - row_sum - 0.5 if np.random.rand() > 0.5 else 0
                G[i, j] = value
                row_sum += value
    return G

Gn = generate_adjusted_matrix(n)
G_transpose = Gn.T

# Function to generate a diagonal matrix V
def generate_diagonal_matrix(n):
    possible_values_diagonal = [-1, 1, 0.5, -0.5]
    V = np.zeros((n, n))
    for i in range(n):
        V[i, i] = np.random.choice(possible_values_diagonal)
    return V

V = generate_diagonal_matrix(n)

# Function to calculate pivotal probabilities
def calculate_pivotal_probabilities(x, n, Psi):
    pivotal_probs = np.zeros(n)
    for i in range(n):
        others = np.concatenate((x[:i], x[i+1:]))
        for j in range(n//2):
            pivotal_probs[i] += comb(n - 1, j) * np.prod(others[:j]) * np.prod(1 - others[j:])
    return pivotal_probs / (2**(n - 1))

# Function to solve the system for x*
def solve_system(n, phi, Psi, Gn):
    x = np.full(n, 0.5)  # Initial guess
    for _ in range(1000):  # Max iterations
        pivotal_probs = calculate_pivotal_probabilities(x, n, Psi)
        x_new = np.array([q + Psi * phi * sum(Gn[i, :] * (1 - x)) for i in range(n)])
        if np.allclose(x, x_new, atol=1e-6):
            return x
        x = x_new
    raise ValueError("The system did not converge")

# Lists to store centrality measures for legislators 0 and 19
centrality_0 = []
centrality_19 = []

# Iterate over Psi values and compute b_M for each, then store the required centralities
for Psi in Psi_values:
    x_star = solve_system(n, phi, Psi, Gn)
    V_diag = np.diag(V)
    matrix_inside_brackets = np.eye(n) - (phistar(Psi) * G_transpose + Psi * np.diag(V_diag))
    inverted_matrix = np.linalg.inv(matrix_inside_brackets)
    b_M = inverted_matrix.dot(np.ones(n))
    centrality_0.append(b_M[0])
    centrality_19.append(b_M[19])

# Plot the results
plt.figure(figsize=(10, 5))
plt.plot(Psi_values, centrality_0, label='Legislator 0 Centrality', marker='o')
plt.plot(Psi_values, centrality_19, label='Legislator 19 Centrality', marker='o')
plt.title('Katz-Bonacich Centrality of Legislators 0 and 19 vs Psi')
plt.xlabel('Psi')
plt.ylabel('Katz-Bonacich Centrality Measure')
plt.legend()
plt.grid(True)
plt.show()
